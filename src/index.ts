import type {
  AssignOptions,
  Collection,
  CreateOptions,
  EntityClass,
  EntityData,
  IDatabaseDriver,
  Primary,
  PrimaryProperty,
  Reference,
  RequiredEntityData,
} from "@mikro-orm/core";
import { EntityManager, wrap } from "@mikro-orm/core";

// =============================================================================
// UnflushedEntityError
// =============================================================================

export class UnflushedEntityError extends Error {
  public readonly entityName: string;
  public readonly undefinedFields: string[];
  public readonly context?: string | object;

  constructor(
    entityName: string,
    undefinedFields: string[],
    context?: string | object,
  ) {
    const message =
      typeof context === "string"
        ? context
        : `Entity ${entityName} not flushed: database-generated fields are undefined: ${undefinedFields.join(", ")}`;

    super(message);
    this.name = "UnflushedEntityError";
    this.entityName = entityName;
    this.undefinedFields = undefinedFields;
    this.context = context;
  }
}

// =============================================================================
// assertFlushed / isFlushed
// =============================================================================

function getUnflushedFields<T extends object>(entity: T): string[] {
  const meta = wrap(entity, true).__meta;
  const undefinedFields: string[] = [];

  for (const prop of meta.props) {
    const value = (entity as Record<string, unknown>)[prop.name];
    if (value !== undefined) continue;

    const isDbGenerated =
      prop.primary || prop.defaultRaw !== undefined || prop.version;

    if (isDbGenerated) {
      undefinedFields.push(prop.name);
    }
  }

  return undefinedFields;
}

/**
 * Asserts that all database-generated fields on an entity have been populated.
 * Use after `em.flush()` to narrow `Unflushed<T>` back to `T`.
 *
 * Checks primary keys, fields with `defaultRaw`, and version fields.
 *
 * @throws {UnflushedEntityError} if any database-generated field is still `undefined`
 *
 * @example
 * ```ts
 * const user = em.createStrict(User, { email: 'a@b.com' });
 * await em.flush();
 *
 * assertFlushed(user);
 * // user is now narrowed from Unflushed<User> to User
 * ```
 */
export function assertFlushed<T extends object>(
  entity: T | Unflushed<T>,
  errorContext?: string | object,
): asserts entity is T {
  const undefinedFields = getUnflushedFields(entity);

  if (undefinedFields.length > 0) {
    const meta = wrap(entity, true).__meta;
    throw new UnflushedEntityError(
      meta.className,
      undefinedFields,
      errorContext,
    );
  }
}

/**
 * Non-throwing type guard that checks if an entity has been flushed.
 *
 * @example
 * ```ts
 * if (isFlushed(user)) {
 *   console.log(user.id); // narrowed to User
 * }
 * ```
 */
export function isFlushed<T extends object>(
  entity: T | Unflushed<T>,
): entity is T {
  return getUnflushedFields(entity).length === 0;
}

// =============================================================================
// FieldsFor â€” type-safe partial loading paths
// =============================================================================

/** String property keys of T, excluding methods. */
export type DataKey<T> = {
  [K in Extract<keyof T, string>]: T[K] extends (...args: any[]) => any
    ? never
    : K;
}[Extract<keyof T, string>];

type IsRelation<V> =
  NonNullable<V> extends Reference<infer _>
    ? true
    : NonNullable<V> extends Collection<infer _, any>
      ? true
      : false;

type UnwrapRef<V> =
  NonNullable<V> extends Reference<infer U>
    ? U
    : NonNullable<V> extends Collection<infer U, any>
      ? U
      : V;

/**
 * Union of all valid field paths for MikroORM partial loading.
 * Provides autocomplete and compile-time validation.
 *
 * @example
 * ```ts
 * const fields: FieldsFor<LegalEntity>[] = ['*', 'signatories.id'];
 * const entity = await em.findOneOrFail(LegalEntity, { id }, { fields });
 * ```
 */
export type FieldsFor<T, Depth extends unknown[] = [1, 1]> =
  | '*'
  | DataKey<T>
  | (Depth extends [unknown, ...infer Rest]
      ? {
          [K in DataKey<T>]: IsRelation<T[K]> extends true
            ? `${K}.${FieldsFor<UnwrapRef<T[K]>, Rest>}`
            : never;
        }[DataKey<T>]
      : never);

// =============================================================================
// Utility types
// =============================================================================

/** Extracts relation keys (Ref<T> properties) from a MikroORM entity. */
export type ExtractRelations<T> = Exclude<
  {
    [K in keyof T]: NonNullable<T[K]> extends Reference<infer _> ? K : never;
  }[keyof T],
  undefined
>;

/**
 * Keys whose values are database-generated (primary keys with defaults,
 * `defaultRaw` fields, `Opt`-marked fields, etc.).
 */
type AutoGeneratedKeys<T> = {
  [K in keyof T]-?: K extends keyof RequiredEntityData<T>
    ? undefined extends RequiredEntityData<T>[K]
      ? undefined extends T[K]
        ? never
        : K
      : never
    : never;
}[keyof T];

/**
 * An entity whose database-generated fields may still be `undefined`.
 * Returned by `createStrict` -- narrow back with `assertFlushed` after flushing.
 */
export type Unflushed<T> = {
  [K in keyof T]: K extends AutoGeneratedKeys<T> ? T[K] | undefined : T[K];
};

/**
 * An entity where only the primary key is guaranteed.
 * Returned by `getStrictReference` and `assignStrict`.
 */
export type PartialEntity<T> = {
  [K in keyof T]: K extends PrimaryProperty<T> ? T[K] : T[K] | undefined;
};

/**
 * Compile-time check that all keys in `Dto` exist on `Entity`.
 * Produces a descriptive tuple error type on mismatch.
 */
type StrictEntityKeys<Entity, Dto> = {
  [K in keyof Dto]: K extends keyof Entity
    ? Dto[K]
    : ["Error: key does not exist on entity:", K];
};

// =============================================================================
// Prototype augmentation
// =============================================================================

/* eslint-disable @typescript-eslint/no-explicit-any */
const emProto: any = EntityManager.prototype;
const _assign = emProto.assign;
const _create = emProto.create;
const _getReference = emProto.getReference;

emProto.assignStrict = function (
  this: any,
  entity: any,
  data: any,
  options?: any,
) {
  return _assign.call(this, entity, data, options);
};

emProto.createStrict = function (
  this: any,
  entityName: any,
  data: any,
  options?: any,
) {
  return _create.call(this, entityName, data, options);
};

emProto.getStrictReference = function (
  this: any,
  entityName: any,
  id: any,
) {
  return _getReference.call(this, entityName, id);
};
/* eslint-enable @typescript-eslint/no-explicit-any */

// =============================================================================
// Type declarations (interfaces for the new methods)
// =============================================================================

interface AssignStrictMethod {
  /**
   * Type-safe `em.assign()` that validates DTO keys exist on the entity
   * and returns `PartialEntity<Entity>` (only PK guaranteed).
   *
   * @example
   * ```ts
   * const user = em.getStrictReference(User, userId);
   * em.assignStrict(user, { firstName: 'John' });
   * // user.firstName is string | undefined (partial state)
   *
   * em.assignStrict(user, { firstNme: 'John' }); // compile error
   * ```
   */
  assignStrict<Entity extends object, Dto extends Partial<EntityData<Entity>>>(
    entity: Entity,
    data: Dto & StrictEntityKeys<Entity, Dto>,
    options?: AssignOptions<boolean>,
  ): PartialEntity<Entity>;
}

interface CreateStrictMethod {
  /**
   * Type-safe `em.create()` that validates DTO keys and returns
   * `Unflushed<Entity>` where database-generated fields are `T | undefined`.
   *
   * @example
   * ```ts
   * const user = em.createStrict(User, { email: 'a@b.com' });
   * user.id;        // string | undefined (not yet generated)
   * user.email;     // string
   *
   * await em.flush();
   * assertFlushed(user); // narrows to User
   * ```
   */
  createStrict<Entity extends object, Dto extends RequiredEntityData<Entity>>(
    entityName: EntityClass<Entity>,
    data: Dto & StrictEntityKeys<Entity, Dto>,
    options?: CreateOptions<boolean>,
  ): Unflushed<Entity>;
}

interface GetStrictReferenceMethod {
  /**
   * Creates an entity reference with only the primary key.
   * No database query is executed. Use with `assignStrict` for
   * update-without-select patterns.
   *
   * @example
   * ```ts
   * const user = em.getStrictReference(User, userId);
   * em.assignStrict(user, { deletedAt: new Date() });
   * await em.flush(); // UPDATE without prior SELECT
   * ```
   */
  getStrictReference<Entity extends object>(
    entityName: EntityClass<Entity>,
    id: Primary<Entity>,
  ): PartialEntity<Entity>;
}

// =============================================================================
// Module augmentation
// =============================================================================

export type StrictMethods = AssignStrictMethod &
  CreateStrictMethod &
  GetStrictReferenceMethod;

declare module '@mikro-orm/core' {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  interface EntityManager<Driver extends IDatabaseDriver = IDatabaseDriver>
    extends StrictMethods {}
}
